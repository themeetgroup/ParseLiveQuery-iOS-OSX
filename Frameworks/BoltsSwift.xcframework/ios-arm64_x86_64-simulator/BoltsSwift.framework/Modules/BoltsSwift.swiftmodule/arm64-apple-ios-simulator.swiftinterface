// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name BoltsSwift
@_exported import BoltsSwift
import Foundation
import Swift
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct AggregateError : Swift.Error {
  public let errors: [any Swift.Error]
}
public struct CancelledError : Swift.Error {
  public init()
}
public enum Executor {
  case `default`
  case immediate
  case mainThread
  case queue(Dispatch.DispatchQueue)
  case operationQueue(Foundation.OperationQueue)
  case closure((() -> Swift.Void) -> Swift.Void)
  case escapingClosure((() -> Swift.Void) -> Swift.Void)
  public func execute(_ closure: @escaping () -> Swift.Void)
}
extension BoltsSwift.Executor : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class Task<TResult> {
  public typealias Continuation = () -> Swift.Void
  public init(_ result: TResult)
  public init(error: any Swift.Error)
  final public class func cancelledTask() -> Self
  convenience public init(_ executor: BoltsSwift.Executor = .default, closure: @escaping (() throws -> TResult))
  final public class func execute(_ executor: BoltsSwift.Executor = .default, closure: @escaping (() throws -> TResult)) -> BoltsSwift.Task<TResult>
  final public class func executeWithTask(_ executor: BoltsSwift.Executor = .default, closure: @escaping (() throws -> BoltsSwift.Task<TResult>)) -> BoltsSwift.Task<TResult>
  final public var completed: Swift.Bool {
    get
  }
  final public var faulted: Swift.Bool {
    get
  }
  final public var cancelled: Swift.Bool {
    get
  }
  final public var result: TResult? {
    get
  }
  final public var error: (any Swift.Error)? {
    get
  }
  final public func waitUntilCompleted()
  @objc deinit
}
extension BoltsSwift.Task : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
}
extension BoltsSwift.Task {
  @discardableResult
  final public func continueWith<S>(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((BoltsSwift.Task<TResult>) throws -> S)) -> BoltsSwift.Task<S>
  @discardableResult
  final public func continueWithTask<S>(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((BoltsSwift.Task<TResult>) throws -> BoltsSwift.Task<S>)) -> BoltsSwift.Task<S>
}
extension BoltsSwift.Task {
  @discardableResult
  final public func continueOnSuccessWith<S>(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((TResult) throws -> S)) -> BoltsSwift.Task<S>
  @discardableResult
  final public func continueOnSuccessWithTask<S>(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((TResult) throws -> BoltsSwift.Task<S>)) -> BoltsSwift.Task<S>
}
extension BoltsSwift.Task {
  @discardableResult
  final public func continueOnErrorWith<E>(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((E) throws -> TResult)) -> BoltsSwift.Task<TResult> where E : Swift.Error
  @discardableResult
  final public func continueOnErrorWith(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((any Swift.Error) throws -> TResult)) -> BoltsSwift.Task<TResult>
  @discardableResult
  final public func continueOnErrorWithTask<E>(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((E) throws -> BoltsSwift.Task<TResult>)) -> BoltsSwift.Task<TResult> where E : Swift.Error
  @discardableResult
  final public func continueOnErrorWithTask(_ executor: BoltsSwift.Executor = .default, continuation: @escaping ((any Swift.Error) throws -> BoltsSwift.Task<TResult>)) -> BoltsSwift.Task<TResult>
}
extension BoltsSwift.Task {
  final public class func withDelay(_ delay: Foundation.TimeInterval) -> BoltsSwift.Task<Swift.Void>
}
extension BoltsSwift.Task {
  final public class func whenAll(_ tasks: [BoltsSwift.Task<TResult>]) -> BoltsSwift.Task<Swift.Void>
  final public class func whenAll(_ tasks: BoltsSwift.Task<TResult>...) -> BoltsSwift.Task<Swift.Void>
  final public class func whenAllResult(_ tasks: [BoltsSwift.Task<TResult>]) -> BoltsSwift.Task<[TResult]>
  final public class func whenAllResult(_ tasks: BoltsSwift.Task<TResult>...) -> BoltsSwift.Task<[TResult]>
}
extension BoltsSwift.Task {
  final public class func whenAny(_ tasks: [BoltsSwift.Task<TResult>]) -> BoltsSwift.Task<Swift.Void>
  final public class func whenAny(_ tasks: BoltsSwift.Task<TResult>...) -> BoltsSwift.Task<Swift.Void>
}
public class TaskCompletionSource<TResult> {
  final public let task: BoltsSwift.Task<TResult>
  public init()
  public func set(result: TResult)
  public func set(error: any Swift.Error)
  public func cancel()
  @discardableResult
  public func trySet(result: TResult) -> Swift.Bool
  @discardableResult
  public func trySet(error: any Swift.Error) -> Swift.Bool
  @discardableResult
  public func tryCancel() -> Swift.Bool
  @objc deinit
}
